\1. 类的加载过程，Person person = new Person();为例进行说明。

1).因为new用到了Person.class，所以会先找到Person.class文件，并加载到内存中;

2).执行该类中的static代码块，对Person.class类进行初始化;

3).在堆内存中开辟空间分配内存地址;

4).在堆内存中建立对象的特有属性，并进行默认初始化;

5).对属性进行显示初始化;

6).对对象进行构造代码块初始化;

7).对对象进行与之对应的构造函数进行初始化;

8).将内存地址付给栈内存中的p变量

# 2[equals与==的区别](http://coding.imooc.com/class/101.html)?

==是判断两个变量或实例是不是指向同一个内存空间

equals是判断两个变量或实例所指向的内存空间的值是不是相同

# 3[Object](http://coding.imooc.com/class/101.html)有哪些公用方法？

方法equals测试的是两个对象是否相等

方法clone进行对象拷贝

方法getClass返回和当前对象相关的Class对象

方法notify,notifyall,wait都是用来对给定对象进行线程同步的

实际开发中[软引用或者弱引用](http://coding.imooc.com/class/101.html)的使用场景：

利用软引用和弱引用解决OOM问题：用一个HashMap来保存图片的路径和相应图片对象关联的软引用之间的映射关系，在内存不足时，JVM会自动回收这些缓存图片对象所占用的空间，从而有效地避免了OOM的问题

通过软可及对象重获方法实现Java对象的高速缓存:比如我们创建了一Employee的类，如果每次需要查询一个雇员的信息。哪怕是几秒中之前刚刚查询过的，都要重新构建一个实例，这是需要消耗很多时间的。我们可以通过软引用和 HashMap 的结合，先是保存引用方面：以软引用的方式对一个Employee对象的实例进行引用并保存该引用到HashMap 上，key 为此雇员的 id，value为这个对象的软引用，另一方面是取出引用，缓存中是否有该Employee实例的软引用，如果有，从软引用中取得。如果没有软引用，或者从软引用中得到的实例是null，重新构建一个实例，并保存对这个新建实例的软引用

# 4[Hashcode](http://coding.imooc.com/class/101.html)的作用与equal 有什么区别?

同样用于鉴定2个对象是否相等的，java集合中有list和set两类，其中set不允许元素重复实现，如果用equal去比较的话，如果存在1000个元素，new一个新的元素出来，需要去调用1000次equal去逐个和他们比较是否是同一个对象，这样会大大降低效率。hashcode实际上是返回对象的存储地址，如果这个位置上没有元素，就把元素直接存储在上面，如果这个位置上已经存在元素，这个时候才去调用equal方法与新元素进行比较，相同的话就不存了，散列到其他地址上

# 5String、StringBuffer与StringBuilder的区别?

String 类型和 StringBuffer 类型的主要性能区别其实在于 String 是不可变的对象

StringBuffer和StringBuilder底层是char[]数组实现的

StringBuffer是线程安全的，而StringBuilder是线程不安全的

# 6Override和Overload的含义去区别?

Overload顾名思义是重新加载，它可以表现类的多态性，可以是函数里面可以有相同的函数名但是参数名、返回值、类型不能相同；或者说可以改变参数、类型、返回值但是函数名字依然不变。

Override顾名思义就是ride(重写)的意思，在子类继承父类的时候子类中可以定义某方法与其父类有相同的名称和参数，当子类在调用这一函数时自动调用子类的方法，而父类相当于被覆盖（重写）了。

# 7抽象类和接口的区别?

一个类只能继承单个类，但是可以实现多个接口

接口强调特定功能的实现，而抽象类强调所属关系

抽象类中的所有方法并不一定要是抽象的，你可以选择在抽象类中实现一些基本的方法。而接口要求所有的方法都必须是抽象的

# 8解析XML的几种方式的原理与特点：DOM、SAX、PULL?

DOM：消耗内存：先把xml文档都读到内存中，然后再用DOM API来访问树形结构，并获取数据。这个写起来很简单，但是很消耗内存。要是数据过大，手机不够牛逼，可能手机直接死机

SAX：解析效率高，占用内存少，基于事件驱动的：更加简单地说就是对文档进行顺序扫描，当扫描到文档(document)开始与结束、元素(element)开始与结束、文档(document)结束等地方时通知事件处理函数，由事件处理函数做相应动作，然后继续同样的扫描，直至文档结束。

SAX：与 SAX 类似，也是基于事件驱动，我们可以调用它的next（）方法，来获取下一个解析事件（就是开始文档，结束文档，开始标签，结束标签），当处于某个元素时可以调用XmlPullParser的getAttributte()方法来获取属性的值，也可调用它的nextText()获取本节点的值。

# 9wait()和sleep()的区别?

sleep来自Thread类，wait来自Object类

调用sleep()方法的过程中，线程不会释放对象锁。而调用wait方法线程会释放对象锁。

sleep睡眠后不出让系统资源，wait让出系统资源其他线程可以占用CPU

sleep(milliseconds)需要指定一个睡眠时间，时间一到会自动唤醒。

# 10JAVA多态的实现原理?

抽象的来讲，多态的意思就是同一消息可以根据发送对象的不同而采用多种不同的行为方式。（发送消息就是函数调用）

实现的原理是动态绑定，程序调用的方法在运行期才动态绑定，追溯源码可以发现，JVM 通过参数的自动转型来找到合适的办法。

# 11JVM基本构成

从上图可知，JVM主要包括四个部分：

**1.**   **类加载器**（ClassLoader）:在JVM启动时或者在类运行时将需要的class加载到JVM中。（下图表示了从java源文件到JVM的整个过程）



**2.****执行引擎**：负责执行class文件中包含的字节码指令；

**3.****内存区**（也叫运行时数据区）：是在JVM运行的时候操作所分配的内存区。运行时内存区主要可以划分为5个区域，如图：



方法区(Method Area)：用于存储类结构信息的地方，包括常量池、静态变量、构造函数等。虽然JVM规范把方法区描述为堆的一个逻辑部分，但它却有个别名non-heap（非堆），所以大家不要搞混淆了。方法区还包含一个运行时常量池。

java堆(Heap)：存储java实例或者对象的地方。这块是GC的主要区域。从存储的内容我们可以很容易知道，方法区和堆是被所有java线程共享的。

java栈(Stack)：java栈总是和线程关联在一起，每当创建一个线程时，JVM就会为这个线程创建一个对应的java栈。在这个java栈中又会包含多个栈帧，每运行一个方法就创建一个栈帧，用于存储局部变量表、操作栈、方法返回值等。每一个方法从调用直至执行完成的过程，就对应一个栈帧在java栈中入栈到出栈的过程。所以java栈是现成私有的。

程序计数器(PC Register)：用于保存当前线程执行的内存地址。由于JVM程序是多线程执行的（线程轮流切换），所以为了保证线程切换回来后，还能恢复到原先状态，就需要一个独立的计数器，记录之前中断的地方，可见程序计数器也是线程私有的。

本地方法栈(Native Method Stack)：和java栈的作用差不多，只不过是为JVM使用到的native方法服务的。

**4.****本地方法接口**：主要是调用C或C++实现的本地方法及返回结果。

# 12JAVA 垃圾回收与内存分配策略?

## 12.1垃圾回收是什么？

就是释放那些不再持有引用的对象的内存

## 12.2怎么判断一个对象是否需要收集？

**引用计数**（最简单古老的方法）：指将资源（可以是对象、内存或磁盘空间等等）的被引用次数保存起来，当被引用次数变为零时就将其释放的过程。引用计数缺陷：引用计数无法解决循环引用问题：假设对象A，B都已经被实例化，让A=B,B=A,除此之外这两个对象再无任何引用，此时计数器的值就永远不可能为0，但是引用计数器无法通知gc回收他们

**对象引用遍历**（现在大多数jvm使用的方法）：对象引用遍历从一组对象开始，沿着整个对象图上的每条链接，递归确定可到达（reachable）的对象。如果某对象不能从这些根对象的一个（至少一个）到达，则将它作为垃圾收集

## 12.3Java的四种引用的区别

**强引用**：如果一个对象具有强引用，它就不会被垃圾回收器回收。即使当前内存空间不足，JVM 也不会回收它，而是抛出 OutOfMemoryError 错误，使程序异常终止。如果想中断强引用和某个对象之间的关联，可以显式地将引用赋值为null，这样一来的话，JVM在合适的时间就会回收该对象

**软引用**：在使用软引用时，如果内存的空间足够，软引用就能继续被使用，而不会被垃圾回收器回收，只有在内存不足时，软引用才会被垃圾回收器回收。

**弱引用**：具有弱引用的对象拥有的生命周期更短暂。因为当JVM进行垃圾回收，一旦发现弱引用对象，无论当前内存空间是否充足，都会将弱引用回收。不过由于垃圾回收器是一个优先级较低的线程，所以并不一定能迅速发现弱引用对象

**虚引用**：顾名思义，就是形同虚设，如果一个对象仅持有虚引用，那么它相当于没有引用，在任何时候都可能被垃圾回收器回收。

## 12.4介绍垃圾回收机制

**标记回收法**：遍历对象图并且记录可到达的对象，以便删除不可到达的对象，一般使用单线程工作并且可能产生内存碎片

**标记****-****压缩回收法**：前期与第一种方法相同，只是多了一步，将所有的存活对象压缩到内存的一端，这样内存碎片就可以合成一大块可再利用的内存区域，提高了内存利用率

**复制回收法**：把现有内存空间分成两部分，gc运行时，它把可到达对象复制到另一半空间，再清空正在使用的空间的全部对象。这种方法适用于短生存期的对象，持续复制长生存期的对象则导致效率降低。

**分代回收法**：把内存空间分为两个或者多个域，如年轻代和老年代，年轻代的特点是对象会很快被回收，因此在年轻代使用效率比较高的算法。当一个对象经过几次回收后依然存活，对象就会被放入称为老年的内存空间，老年代则采取标记-压缩算法

## 12.5JAVA 中堆和栈的区别

基本数据类型如变量和对象的引用都是在栈分配的。堆内存用来存放由new创建的对象和数组。

类变量（static修饰的变量），程序在加载的时候就在堆中为类变量分配内存，堆中的内存地址存放在栈中

实例变量：当使用java关键字new的时候，系统在堆中开辟并不一定是连续的空间分配给变量，是根据零散的堆内存地址，通过哈希算法换算为一长串数字以表征这个变量在堆中的”物理位置”,实例变量的生命周期–当实例变量的引用丢失后，将被GC（垃圾回收器）列入可回收“名单”中，但并不是马上就释放堆中内存

局部变量:由声明在某方法，或某代码段里（比如for循环），执行到它的时候在栈中开辟内存，当局部变量一但脱离作用域，内存立即释放

# 13Java 集合系列问题

## 13.1list，map，set都有哪些具体的实现类，区别都是什么？

a. List,Set都是继承自Collection接口，Map则不是。

**b. List****特点：**元素有放入顺序，元素可重复; **Set****特点：**元素无放入顺序，元素不可重复，重复元素会覆盖掉**（注意：元素虽然无放入顺序，但是元素在set中的位置是由该元素的HashCode决定的，其位置其实是固定的，加入Set 的Object必须定义equals()方法。另外list支持for循环，也就是通过下标来遍历，也可以用迭代器，但是set只能用迭代，因为他无序，无法用下标来取得想要的值）**

c. Set和List对比

Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。

List：和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变。

d. Map适合储存键值对的数据。

e. 线程安全集合类与非线程安全集合类

LinkedList、ArrayList、HashSet是非线程安全的，Vector是线程安全的;

HashMap, TreeMap是非线程安全的，HashTable是线程安全的;

StringBuilder是非线程安全的，StringBuffer是线程安全的。

## 13.2ArrayList、LinkedList、Vector的区别

**存储上**，ArrayList和Vector底层是采用线性连续空间存储元素，随机存取东都比较快，插入和删除都很慢。当空间不足的时候，两个类的增加方式是不同，Vector可以设置增长因子，而ArrayList不可以；**线程安全上**，Vector由于使用了synchronized修饰方法（线程安全）所以Vector是多线程安全的，但性能上比ArrayList要差；**适用场景上**，由于Vector是线程同步的，线程安全的， ArrayList是线程异步的，线程不安全的。如果不考虑到线程的安全因素，一般用ArrayList效率比较高。如果集合中的元素的数目大于目前集合数组的长度时，在集合中使用数据量比较大的数据，用Vector有一定的优势。总的来说，Vector是一种老的动态数组，效率很低，一般不赞成使用。

存储上，LinkedList使用双向链表实现存储，随机存取比较慢，插入和删除很快；线程安全上，也是线程不安全的；应用场景上，用于当要对数据进行随机访问时选用ArrayList，当要对数据进行多次增加删除时采用LinkedList。

## 13.3**HashSet****与****TreeSet****的区别**

**存储上**，TreeSet 是二叉树（红黑树的树据结构）实现的,Treeset中的数据是自动排好序的，不允许放入null值；HashSet是哈希表实现的，HashSet中的数据是无序的，可以放入null，但只能放入一个null。HashSet要求放入的对象必须实现HashCode()方法，放入的对象是以hashcode码作为标识的，具有相同内容的String对象，hashcode是一样。**适用场景上**，由于HashSet是基于Hash算法实现的，其性能通常都优于TreeSet。需快速查找，通常都应该使用HashSet，需要排序功能时，使用TreeSet。

## 13.4 HashMap与TreeMap、HashTable的区别及适用场景

**存储上**，HashMap基于哈希表实现。使用HashMap要求添加的键类明确定义了hashCode()和equals()[可以重写hashCode()和equals()]，为了优化HashMap空间的使用，可以调优初始容量和负载因子。其中散列表的冲突处理主要分两种，一种是开放定址法，另一种是链表法。HashMap的实现中采用的是链表法。TreeMap：基于红黑树实现。TreeMap没有调优选项，因为该树总处于平衡状态。HashTable比较老，是基于Dictionary 类实现的。HashMap去掉了HashTable的contains方法，但是加上了containsValue()和containsKey()方法，HashMap则是基于Map接口实现的。HashMap允许空键值，而HashTable不允许。**线程安全上**，HashMap和TreeMap都是非线程安全，HashTable是线程安全的，因此效率上HashTable不如HashMap。**适用场景上**，HashMap适用于Map中插入、删除和定位元素。Treemap：适用于按自然顺序或自定义顺序遍历键(key)。

 

Fail-Fast机制:在使用迭代器的过程中有其他线程修改了map，那么将抛出ConcurrentModificationException，这就是所谓fail-fast机制。这一机制在源码中的实现是通过modCount域，modCount顾名思义就是修改次数，对HashMap内容的修改都将增加这个值，那么在迭代器初始化过程中会将这个值赋给迭代器的expectedModCount。在迭代过程中，判断modCount跟expectedModCount是否相等，如果不相等就表示已经有其他线程修改了Map

# 14什么是线程池，线程池的作用是什么?

线程池的基本思想还是一种对象池的思想，开辟一块内存空间，里面存放了众多(未死亡)的线程，池中线程执行调度由池管理器来处理。当有线程任务时，从池中取一个，执行完成后线程对象归池，这样可以避免反复创建线程对象所带来的性能开销，节省了系统的资源。

比如：一个应用要和网络打交道，有很多步骤需要访问网络，为了不阻塞主线程，每个步骤都创建一个线程，在线程中和网络交互，用线程池就变的简单，线程池是对线程的一种封装，让线程用起来更加简便，只需要创一个线程池，把这些步骤像任务一样放进线程池，在程序销毁时只要调用线程池的销毁函数即可。

 

## 14.1单个线程的弊端

a. 每次new Thread新建对象性能差

b. 线程缺乏统一管理，可能无限制新建线程，相互之间竞争，及可能占用过多系统资源导致死机,

c. 缺乏更多功能，如定时执行、定期执行、线程中断。

## 14.2java提供的四种线程池的好处在于

a. 重用存在的线程，减少对象创建、消亡的开销，性能佳。

b. 可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。

c. 提供定时执行、定期执行、单线程、并发数控制等功能。

## 14.3多线程的使用场景

**使用多线程就一定效率高吗？** **有时候使用多线程并不是为了提高效率，而是使得****CPU****能够同时处理多个事件。**

1).为了**不阻塞主线程**,启动其他线程来做事。比如APP中耗时操作都不在UI中做.

2).实现**更快的应用程序**,即主线程专门监听用户请求,子线程用来处理用户请求,以获得大的吞吐量。这种情况下，多线程的效率未必高。这种情况下的多线程是为了不必等待， 可以并行处理多条数据。比如JavaWeb的就是主线程专门监听用户的HTTP请求，然后启动子线程去处理用户的HTTP请求。

3).某种虽然优先级很低的服务，但是却要不定时去做。比如**Jvm****的垃圾回收**。

4.)某种任务，虽然耗时，但是不耗CPU的操作时，开启多个线程，效率会有显著提高。比如读取文件，然后处理。**磁盘****IO****是个很耗费时间**，但是不耗CPU计算的工作。 所以可以一个线程读取数据，一个线程处理数据。肯定比一个线程读取数据，然后处理效率高。因为两个线程的时候充分利用了CPU等待磁盘IO的空闲时间。

## 14.4常用的线程池[1]

## 

  1、FixedThreadPool创建一个指定工作线程数量的线程池。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。 

  2、CachedThreadPool创建一个可缓存的线程池。这种类型的线程池特点是： 

  1).工作线程的创建数量几乎没有限制(其实也有限制的,数目为Interger.MAX_VALUE), 这样可灵活的往线程池中添加线程。 

  2).如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间(默认为1分钟)，则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。 

  3、SingleThreadExecutor创建一个单线程化的Executor，即只创建唯一的工作者线程来执行任务，如果这个线程异常结束，会有另一个取代它，保证顺序执行(我觉得这点是它的特色)。单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的 。 

  4、ScheduleThreadPool创建一个定长的线程池，而且支持定时的以及周期性的任务执行，类似于Timer。(这种线程池原理暂还没完全了解透彻) 

  总结： 一.FixedThreadPool是一个典型且优秀的线程池，它具有线程池提高程序效率和节省创建线程时所耗的开销的优点。但是，在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源。 

​    二．CachedThreadPool的特点就是在线程池空闲时，即线程池中没有可运行任务时，它会释放工作线程，从而释放工作线程所占用的资源。但是，但当出现新任务时，又要创建一新的工作线程，又要一定的系统开销。并且，在使用CachedThreadPool时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有会造成系统瘫痪。 

# 15concurrentHashmap原理，原子类。

ConcurrentHashMap作为一种线程安全且高效的哈希表的解决方案，尤其其中的"分段锁"的方案，相比HashTable的全表锁在性能上的提升非常之大.

# 16简单介绍一下java中的泛型，泛型擦除以及相关的概念。

泛型是Java SE 1.5的新特性，泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口、泛型方法。Java语言引入泛型的好处是安全简单。

在Java SE 1.5之前，没有泛型的情况的下，通过对类型Object的引用来实现参数的“任意化”，“任意化”带来的缺点是要做显式的强制类型转换，而这种转换是要求开发者对实际参数类型可以预知的情况下进行的。对于强制类型转换错误的情况，编译器可能不提示错误，在运行的时候才出现异常，这是一个安全隐患。泛型的好处是在编译的时候检查类型安全，并且所有的强制转换都是自动和隐式的，提高代码的重用率。

1、泛型的类型参数只能是类类型（包括自定义类），不能是简单类型。

2、同一种泛型可以对应多个版本（因为参数类型是不确定的），不同版本的泛型类实例是不兼容的。

3、泛型的类型参数可以有多个。

4、泛型的参数类型可以使用extends语句，例如<T extends superclass>。习惯上称为“有界类型”。

5、泛型的参数类型还可以是通配符类型。例如Class<?> classType = Class.forName("java.lang.String");

## 16.1 泛型擦除以及相关的概念

Java中的泛型基本上都是在编译器这个层次来实现的。在生成的Java字节码中是不包含泛型中的类型信息的。使用泛型的时候加上的类型参数，会在编译器在编译的时候去掉。这个过程就称为类型擦除。

## 16.2 类型擦除引起的问题及解决方法

1、先检查，再编译，以及检查编译的对象和引用传递的问题

2、自动类型转换

3、类型擦除与多态的冲突和解决方法

4、泛型类型变量不能是基本数据类型

5、运行时类型查询

6、异常中使用泛型的问题

7、数组（这个不属于类型擦除引起的问题）

9、类型擦除后的冲突

10、泛型在静态方法和静态类中的问题

# 17乐观锁和悲观锁

无论是悲观锁还是乐观锁，都是人们针对于不同的业务场景定义出来的概念，是不同的并发控制方式，可以认为是一种思想。不仅仅是关系型数据库系统中有乐观锁和悲观锁的概念，像memcache、hibernate、tair等都有类似的概念。不要把乐观并发控制和悲观并发控制狭义的理解为DBMS中的概念，更不要把他们和数据中提供的锁机制（行锁、表锁、排他锁、共享锁）混为一谈。

**悲观锁（Pessimistic Lock****）**： 每次获取数据的时候，都会担心数据被修改，所以每次获取数据的时候都会进行加锁，确保在自己使用的过程中数据不会被别人修改，使用完成后进行解锁。由于数据进行加锁，期间对该数据进行读写的其他线程都会进行等待。使用数据库的排它锁实现。独占锁是一种悲观锁，而 synchronized 就是一种独占锁，synchronized 会导致其它所有未持有锁的线程阻塞，而等待持有锁的线程释放锁。乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。

**乐观锁（Optimistic Lock****）**： 每次获取数据的时候，都不会担心数据被修改，所以每次获取数据的时候都不会进行加锁，但是在更新数据的时候需要判断该数据是否被别人修改过。如果数据被其他线程修改，则不进行数据更新，如果数据没有被其他线程修改，则进行数据更新。由于数据没有进行加锁，期间该数据可以被其他线程进行读写操作。

适用场景：

悲观锁：比较适合**写入频繁**的场景。如果出现大量的读取操作，每次读取的时候都会进行加锁，这样会增加大量的锁的开销，降低了系统的吞吐量。

乐观锁：比较适合**读取频繁**的场景。如果出现大量的写入操作，数据发生冲突的可能性就会增大，为了保证数据的一致性，应用层需要不断的重新获取数据，这样会增加大量的查询操作，降低了系统的吞吐量。

## 17.1实现乐观锁

1.使用版本号方式

为表加version字段或时间戳字段，使用版本标识来确定读到的数据与提交时的数据是否一致。提交后修改版本标识，不一致时可以采取丢弃和再次尝试的策略。

2.使用CAS方式

CAS操作包含三个操作数：**内存值**（V）、**预期原值**（A）、**新值**(B)。内存值==预期原值？将该内存值更新为新值：设定预期期望值为当前内存值。包java.util.concurrent.atomic

# 18Volatile

## 18.1volatile有什么用？能否用一句话说明下volatile的应用场景

1.volatile的作用是保持变量在多线程情况下的可见性

2.应用场景： 1 写 N 读 eg:活动开关、发布开关

3.多线程情况下正确使用 volatile 的条件:1.对于变量的写操作不依赖于变量的当前值。(如果值只从单线程写入则可以忽略这个条件) 2.该变量没有包含在具有其他变量的不变式中。

## 18.2Volatile和synchronized的区别

1.volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。

2.volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的

3.volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性

4.volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。

5.volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化

6.volatile有什么用？能否用一句话说明下volatile的应用场景

# 20参考

[1]   JAVA线程池原理以及几种线程池类型介绍 - CSDN博客http://blog.csdn.net/moudaen/article/details/14519921