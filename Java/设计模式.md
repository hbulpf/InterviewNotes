\1. 适配器模式

 适用场景

 a.系统需要重用现有类 来配合新接口功能

 b.将彼此无关联的类组装起来一起使用

1.外观模式

 适用场景

 a.为一系列子系统提供一个统一的简单入口

 b.解耦子系统与客户端

 c.在层次化结构中为每一层定义入口，降低层之间的耦合度

1.代理模式

 适用场景

 a.控制对象访问

 b.引入额外操作

\1. 责任链模式

 适用场景

 a.有多个对象可以处理同一请求

 b.动态处理一组对象请求时可以改变其优先顺序

 c.责任链不宜过长，避免死循环

\1. 观察者模式

 适用场景

 a.在一个抽象模型中，一方面依赖另一方面，将这两方面封装在独立的对象中，使各自独立改变和复用

 b.一个对象的改变会导致一个或多个其他对象也发生改变

 c.需要创建一个顺序触发链

\1. 策略模式

 适用场景

 a.一个系统动态地在几种算法中选择一种

 b.有多个条件语句，需要将其转到具体的策略中实现

 c.不希望调用者知道复杂的与算法相关的数据结构，隐藏底层实现细节

```
1. 装饰模式和代理模式有哪些区别？
```



> - 技术点：装饰模式、代理模式
> - 参考回答：
>   - 使用目的不同：代理模式是给目标对象提供一个代理对象，并由代理对象控制对目标对象的引用；装饰模式是在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能
>   - 构造不同：代理模式内部保持对目标对象的引用；装饰模式是通过构造函数传参的方式得到目标对象

```
1. 实现单例模式有几种方法？懒汉式中双层锁的目的是什么？两次判空的目的又是什么？
```

> - 技术点：单例模式
> - 参考回答：实现单例模式常见的两种方式：
>   （1）懒汉式：延迟加载，同时也要保证多线程环境下会产生多个single对象
>
> \```

```
public class Singleton {

    private Singleton() {}
    pprivate volatile static Singleton instance;//第一层锁：保证变量可见性

    public static Singleton getInstance() {
        if (single == null) {//第一次判空：无需每次都加锁，提高性能
            synchronized (Singleton.class) {//第二层锁：保证线程同步
                if (single == null) {//第二次判空:避免多线程同时执行getInstance()产生多个single对象
                    single = new Singleton();
                }
            }
        }
        return single;
    }
}
​```
```

> （2）饿汉式：在类加载初始化时就创建好一个静态的对象供外部使用

\````public class Singleton {     private Singleton() {}    private static Singleton single = new Singleton();     public static Singleton getInstance() {        return single;    } } `

\`````

```
1.谈谈了解的设计模式原则？
```

> - 技术点：设计模式原则
>
> - 参考回答：
>
> - - 单一职责原则：一个类只负责一个功能领域中的相应职责
>   - 开放封闭原则：对扩展开放，对修改关闭
>   - 依赖倒置原则：抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程
>   - 迪米特法则：应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用
>   - 合成/聚合复用原则：要尽量使用合成/聚合，尽量不要使用继承
>
> 
>
> ```
> 1. 谈谈MVC、MVP和MVVM，好在哪里，不好在哪里？
> ```
>
> > - 技术点：MVC、MVP、MVVM
> >
> > - 思路：详见[MVP、MVVM模式](https://www.jianshu.com/p/e0867ac2a261)
> >
> > - 参考回答：
> >
> >   - MVP的含义：
> >
> >     - **Model**：数据层，负责存储、检索、操纵数据。
> >     - **View：UI**层，显示数据，并向Presenter报告用户行为。
> >     - **Presenter**：作为View与Model交互的中间纽带，从Model拿数据，应用到UI层，管理UI的状态，响应用户的行为。
> >
> >   - MVP相比于MVC的
> >
> >     优势
> >
> >     ：
> >
> >     - 分离了视图逻辑和业务逻辑，降低了耦合。
> >     - Activity只处理生命周期的任务，代码变得更加**简洁**。
> >     - 视图逻辑和业务逻辑分别抽象到了View和Presenter的**接口**中去，提高代码的可阅读性。
> >     - Presenter被抽象成接口，可以有多种具体的实现，所以方便进行**单元测试**。
> >     - 把业务逻辑抽到Presenter中去，避免后台线程引用着Activity导致Activity的资源无法被系统回收从而引起**内存泄露**和OOM。
> >
> >   - MVVM的含义：与MVP类似，利用**数据绑定**(Data Binding)、**依赖属性**(Dependency Property)、**命令**(Command)、**路由事件**(Routed Event)等新特性，打造了一个更加灵活高效的架构。
> >
> >   - MVVM相比于MVP的**优势**：在常规的开发模式中，数据变化需要更新UI的时候，需要先获取UI控件的引用，然后再更新UI，获取用户的输入和操作也需要通过UI控件的引用，但在MVVM中，这些都是通过**数据驱动**来自动完成的，数据变化后会自动更新UI，UI的改变也能自动反馈到数据层，数据成为主导因素。这样MVVM层在业务逻辑处理中只要关心数据，不需要直接和UI打交道，在业务处理过程中简单方便很多。
>
> ```
> 1. 如何理解生产者消费者模型？
> ```
>
> > - 技术点：生产者消费者模型
> > - 参考回答：生产者消费者模型通过一个缓存队列，既解决了生产者和消费者之间强耦合的问题，又平衡了生产者和消费者的处理能力。
> >   - 具体规则：生产者只在缓存区未满时进行生产，缓存区满时生产者进程被阻塞；消费者只在缓存区非空时进行消费，缓存区为空时消费者进程被阻塞；当消费者发现缓存区为空时会通知生产者生产；当生产者发现缓存区满时会通知消费者消费。
> >   - 实现关键：synchronized保证对象只能被一个线程占用；wait()让当前线程进入等待状态，并释放它所持有的锁；notify()&notifyAll()唤醒一个（所有）正处于等待状态的线程
>
> ```
> 1. 是否能从Android中举几个例子说说用到了什么设计模式？
> ```
>
> > - 技术点：设计模式
> > - 参考回答：
> >   - View事件分发：责任链模式
> >   - BitmapFactory加载图片：工厂模式
> >   - Adapter：适配器模式
> >   - Builder：建造者模式
> >   - Adpter.notifyDataSetChanged()：观察者模式
> >   - Binder机制：代理模式