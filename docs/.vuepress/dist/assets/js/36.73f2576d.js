(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{387:function(a,e,t){"use strict";t.r(e);var s=t(42),r=Object(s.a)({},(function(){var a=this,e=a.$createElement,t=a._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("p",[t("strong",[a._v("1、如何批量删除或者停止运行的容器？")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("docker kill/rm `docker ps -aq`\n")])])]),t("p",[t("strong",[a._v("2、如何查看镜像支持的环境变量？")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("使用sudo docker run IMAGE env\n")])])]),t("p",[t("strong",[a._v("3、本地的镜像文件都存放在哪里")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("Docker相关的本地资源存放在/var/lib/docker/目录下，其中container目录存放容器信息，graph目录存放镜像信息，aufs目录下存放具体的镜像底层文件。\n")])])]),t("p",[t("strong",[a._v("4、构建Docker镜像应该遵循哪些原则？")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("整体远侧上，尽量保持镜像功能的明确和内容的精简，要点包括： \n# 尽量选取满足需求但较小的基础系统镜像，建议选择debian:wheezy镜像，仅有86MB大小 \n# 清理编译生成文件、安装包的缓存等临时文件 \n# 安装各个软件时候要指定准确的版本号，并避免引入不需要的依赖 \n# 从安全的角度考虑，应用尽量使用系统的库和依赖 \n# 使用Dockerfile创建镜像时候要添加.dockerignore文件或使用干净的工作目录\n")])])]),t("p",[t("strong",[a._v("5、容器退出后，通过docker ps 命令查看不到，数据会丢失么？")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("容器退出后会处于终止（exited）状态，此时可以通过 docker ps -a 查看，其中数据不会丢失，还可以通过docker start 来启动，只有删除容器才会清除数据。\n在这里还要注意开启容器的时候是否添加了--rm参数\n")])])]),t("p",[t("strong",[a._v("6、如何临时退出一个正在交互的容器的终端，而不终止它？")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("按Ctrl+p，后按Ctrl+q，如果按Ctrl+c会使容器内的应用进程终止，进而会使容器终止。\n")])])]),t("p",[t("strong",[a._v("7、很多应用容器都是默认后台运行的，怎么查看它们的输出和日志信息？")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("使用docker logs，后面跟容器的名称或者ID信息\n")])])]),t("p",[t("strong",[a._v("8、使用docker port 命令映射容器的端口时，系统报错Error: No public port ‘80’ published for …，是什么意思？")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("创建镜像时Dockerfile要指定正确的EXPOSE的端口，容器启动时指定PublishAllport=true\n")])])]),t("p",[t("strong",[a._v("9、可以在一个容器中同时运行多个应用进程吗？")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("一般不推荐在同一个容器内运行多个应用进程，如果有类似需求，可以通过额外的进程管理机制，比如supervisord来管理所运行的进程\n")])])]),t("p",[t("strong",[a._v("10、如何控制容器占用系统资源（CPU，内存）的份额？")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("在使用docker create命令创建容器或使用docker run 创建并运行容器的时候，可以使用-c|–cpu-shares[=0]参数来调整同期使用CPU的权重，使用-m|–memory参数来调整容器使用内存的大小。\n")])])]),t("p",[t("strong",[a._v("11、仓库（Repository）、注册服务器（Registry）、注册索引（Index）有何关系？")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("首先，仓库是存放一组关联镜像的集合，比如同一个应用的不同版本的镜像，注册服务器是存放实际的镜像的地方，注册索引则负责维护用户的账号，权限，搜索，标签等管理。注册服务器利用注册索引来实现认证等管理。\n")])])]),t("p",[t("strong",[a._v("12 、从非官方仓库（如：dl.dockerpool.com）下载镜像的时候，有时候会提示“Error：Invaild registry endpoint https://dl.docker.com:5000/v1/…”?")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("Docker 自1.3.0版本往后以来，加强了对镜像安全性的验证，需要手动添加对非官方仓库的信任。 \nDOCKER_OPTS=”–insecure-registry dl.dockerpool.com:5000” \n重启docker服务\n")])])]),t("p",[t("strong",[a._v("13、Docker的配置文件放在那里。如何修改配置？")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("Ubuntu系统下Docker的配置文件是/etc/default/docker，CentOS系统配置文件存放在/etc/sysconfig/docker\n")])])]),t("p",[t("strong",[a._v("14、如何更改Docker的默认存储设置？")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("Docker的默认存放位置是/var/lib/docker,如果希望将Docker的本地文件存储到其他分区，可以使用Linux软连接的方式来做。\n")])])]),t("p",[t("strong",[a._v("15、Docker与LXC（Linux Container）有何不同？")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("LXC利用Linux上相关技术实现容器，Docker则在如下的几个方面进行了改进：\n\n移植性：通过抽象容器配置，容器可以实现一个平台移植到另一个平台； \n镜像系统：基于AUFS的镜像系统为容器的分发带来了很多的便利，同时共同的镜像层只需要存储一份，实现高效率的存储； \n版本管理：类似于GIT的版本管理理念，用户可以更方面的创建、管理镜像文件； \n仓库系统：仓库系统大大降低了镜像的分发和管理的成本； \n周边工具：各种现有的工具（配置管理、云平台）对Docker的支持，以及基于Docker的Pass、CI等系统，让Docker的应用更加方便和多样化。\n")])])]),t("p",[t("strong",[a._v("16 、Docker与Vagrant有何不同？")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("两者的定位完全不同 \nVagrant类似于Boot2Docker（一款运行Docker的最小内核），是一套虚拟机的管理环境，Vagrant可以在多种系统上和虚拟机软件中运行，可以在Windows。Mac等非Linux平台上为Docker支持，自身具有较好的包装性和移植性。 \n原生Docker自身只能运行在Linux平台上，但启动和运行的性能都比虚拟机要快，往往更适合快速开发和部署应用的场景。\n")])])]),t("p",[t("strong",[a._v("17、开发环境中Docker与Vagrant该如何选择？")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("Docker不是虚拟机，而是进程隔离，对于资源的消耗很少，单一开发环境下Vagrant是虚拟机上的封装，虚拟机本身会消耗资源。\n")])])]),t("p",[t("strong",[a._v("18 、如何将一台宿主机的docker环境迁移到另外一台宿主机？")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("停止Docker服务，将整个docker存储文件复制到另外一台宿主机上，然后调整另外一台宿主机的配置即可\n")])])]),t("p",[t("strong",[a._v("19、Docker容器创建后，删除了/var/run/netns 目录下的网络名字空间文件，可以手动恢复它：")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("# 查看容器进程ID，比如1234\nsudo docker inspect --format='{{. State.pid}}' $container_id \n1234\n# 到proc目录下，把对应的网络名字空间文件链接到/var/run/netns,然后通过正常的系统命令查看操作容器的名字空间。\n")])])]),t("p",[t("strong",[a._v("20、给docker容器分配静态ip地址")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("方法1:使用pipework [https://blog.csdn.net/qq_34021712/article/details/73350738]\n方法2：创建一个虚拟网桥和一个虚拟网卡，给该网卡分配一个外网地址，建立容器后（如容器ip为：172.16.25.2）,将该外网ip和容器ip使用dnat做nat网络地址转换，设好出入站映射规则即可。[http://blog.51cto.com/dl528888/1604167]\n")])])])])}),[],!1,null,null,null);e.default=r.exports}}]);