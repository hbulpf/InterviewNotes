(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{363:function(t,v,l){"use strict";l.r(v);var n=l(42),_=Object(n.a)({},(function(){var t=this,v=t.$createElement,l=t._self._c||v;return l("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[l("h1",{attrs:{id:"设计模式"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#设计模式"}},[t._v("#")]),t._v(" 设计模式")]),t._v(" "),l("h2",{attrs:{id:"基本模式"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#基本模式"}},[t._v("#")]),t._v(" 基本模式")]),t._v(" "),l("ol",[l("li",[t._v("适配器模式")])]),t._v(" "),l("ul",[l("li",[t._v("适用场景\na.系统需要重用现有类 来配合新接口功能\nb.将彼此无关联的类组装起来一起使用")])]),t._v(" "),l("ol",{attrs:{start:"2"}},[l("li",[t._v("外观模式")])]),t._v(" "),l("ul",[l("li",[t._v("适用场景")])]),t._v(" "),l("p",[t._v("a.为一系列子系统提供一个统一的简单入口")]),t._v(" "),l("p",[t._v("b.解耦子系统与客户端")]),t._v(" "),l("p",[t._v("c.在层次化结构中为每一层定义入口，降低层之间的耦合度")]),t._v(" "),l("ol",{attrs:{start:"3"}},[l("li",[t._v("代理模式")])]),t._v(" "),l("ul",[l("li",[t._v("适用场景\na.控制对象访问\nb.引入额外操作")])]),t._v(" "),l("ol",{attrs:{start:"4"}},[l("li",[t._v("责任链模式")])]),t._v(" "),l("ul",[l("li",[t._v("适用场景\na.有多个对象可以处理同一请求\nb.动态处理一组对象请求时可以改变其优先顺序\nc.责任链不宜过长，避免死循环")])]),t._v(" "),l("ol",{attrs:{start:"5"}},[l("li",[t._v("观察者模式")])]),t._v(" "),l("ul",[l("li",[t._v("适用场景\na.在一个抽象模型中，一方面依赖另一方面，将这两方面封装在独立的对象中，使各自独立改变和复用\nb.一个对象的改变会导致一个或多个其他对象也发生改变\nc.需要创建一个顺序触发链")])]),t._v(" "),l("ol",{attrs:{start:"6"}},[l("li",[t._v("策略模式")])]),t._v(" "),l("ul",[l("li",[t._v("适用场景\na.一个系统动态地在几种算法中选择一种\nb.有多个条件语句，需要将其转到具体的策略中实现\nc.不希望调用者知道复杂的与算法相关的数据结构，隐藏底层实现细节")])]),t._v(" "),l("h2",{attrs:{id:"问题"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#问题"}},[t._v("#")]),t._v(" 问题")]),t._v(" "),l("ol",[l("li",[t._v("装饰模式和代理模式有哪些区别？")])]),t._v(" "),l("ul",[l("li",[t._v("技术点：装饰模式、代理模式")]),t._v(" "),l("li",[t._v("参考回答：\n"),l("ul",[l("li",[t._v("使用目的不同：代理模式是给目标对象提供一个代理对象，并由代理对象控制对目标对象的引用；装饰模式是在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能")]),t._v(" "),l("li",[t._v("构造不同：代理模式内部保持对目标对象的引用；装饰模式是通过构造函数传参的方式得到目标对象")])])])]),t._v(" "),l("ol",[l("li",[t._v("实现单例模式有几种方法？懒汉式中双层锁的目的是什么？两次判空的目的又是什么？")])]),t._v(" "),l("ul",[l("li",[t._v("技术点：单例模式")]),t._v(" "),l("li",[t._v("参考回答：实现单例模式常见的两种方式：")])]),t._v(" "),l("p",[t._v("（1）懒汉式：延迟加载，同时也要保证多线程环境下会产生多个single对象")]),t._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",{pre:!0,attrs:{class:"language-text"}},[l("code",[t._v("public class Singleton {\n\n    private Singleton() {}\n    pprivate volatile static Singleton instance;//第一层锁：保证变量可见性\n\n    public static Singleton getInstance() {\n        if (single == null) {//第一次判空：无需每次都加锁，提高性能\n            synchronized (Singleton.class) {//第二层锁：保证线程同步\n                if (single == null) {//第二次判空:避免多线程同时执行getInstance()产生多个single对象\n                    single = new Singleton();\n                }\n            }\n        }\n        return single;\n    }\n}\n")])])]),l("p",[t._v("（2）饿汉式：在类加载初始化时就创建好一个静态的对象供外部使用")]),t._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",{pre:!0,attrs:{class:"language-text"}},[l("code",[t._v("public class Singleton {     \n    private Singleton() {}    \n    private static Singleton single = new Singleton();     \n    public static Singleton getInstance() {        \n        return single;    \n    } \n} \n\n")])])]),l("div",{staticClass:"language- extra-class"},[l("pre",{pre:!0,attrs:{class:"language-text"}},[l("code",[t._v("1.谈谈了解的设计模式原则？\n")])])]),l("ul",[l("li",[t._v("技术点：设计模式原则")]),t._v(" "),l("li",[t._v("参考回答：\n"),l("ul",[l("li",[t._v("单一职责原则：一个类只负责一个功能领域中的相应职责")]),t._v(" "),l("li",[t._v("开放封闭原则：对扩展开放，对修改关闭")]),t._v(" "),l("li",[t._v("依赖倒置原则：抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程")]),t._v(" "),l("li",[t._v("迪米特法则：应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用")]),t._v(" "),l("li",[t._v("合成/聚合复用原则：要尽量使用合成/聚合，尽量不要使用继承")])])])]),t._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",{pre:!0,attrs:{class:"language-text"}},[l("code",[t._v("1. 谈谈MVC、MVP和MVVM，好在哪里，不好在哪里？\n")])])]),l("ul",[l("li",[l("p",[t._v("技术点：MVC、MVP、MVVM")])]),t._v(" "),l("li",[l("p",[t._v("思路：详见"),l("a",{attrs:{href:"https://www.jianshu.com/p/e0867ac2a261",target:"_blank",rel:"noopener noreferrer"}},[t._v("MVP、MVVM模式"),l("OutboundLink")],1)])]),t._v(" "),l("li",[l("p",[t._v("参考回答：")]),t._v(" "),l("ul",[l("li",[l("p",[t._v("MVP的含义：")]),t._v(" "),l("ul",[l("li",[l("strong",[t._v("Model")]),t._v("：数据层，负责存储、检索、操纵数据。")]),t._v(" "),l("li",[l("strong",[t._v("View：UI")]),t._v("层，显示数据，并向Presenter报告用户行为。")]),t._v(" "),l("li",[l("strong",[t._v("Presenter")]),t._v("：作为View与Model交互的中间纽带，从Model拿数据，应用到UI层，管理UI的状态，响应用户的行为。")])])]),t._v(" "),l("li",[l("p",[t._v("MVP相比于MVC的")]),t._v(" "),l("p",[t._v("优势")]),t._v(" "),l("p",[t._v("：")]),t._v(" "),l("ul",[l("li",[t._v("分离了视图逻辑和业务逻辑，降低了耦合。")]),t._v(" "),l("li",[t._v("Activity只处理生命周期的任务，代码变得更加"),l("strong",[t._v("简洁")]),t._v("。")]),t._v(" "),l("li",[t._v("视图逻辑和业务逻辑分别抽象到了View和Presenter的"),l("strong",[t._v("接口")]),t._v("中去，提高代码的可阅读性。")]),t._v(" "),l("li",[t._v("Presenter被抽象成接口，可以有多种具体的实现，所以方便进行"),l("strong",[t._v("单元测试")]),t._v("。")]),t._v(" "),l("li",[t._v("把业务逻辑抽到Presenter中去，避免后台线程引用着Activity导致Activity的资源无法被系统回收从而引起"),l("strong",[t._v("内存泄露")]),t._v("和OOM。")])])]),t._v(" "),l("li",[l("p",[t._v("MVVM的含义：与MVP类似，利用"),l("strong",[t._v("数据绑定")]),t._v("(Data Binding)、"),l("strong",[t._v("依赖属性")]),t._v("(Dependency Property)、"),l("strong",[t._v("命令")]),t._v("(Command)、"),l("strong",[t._v("路由事件")]),t._v("(Routed Event)等新特性，打造了一个更加灵活高效的架构。")])]),t._v(" "),l("li",[l("p",[t._v("MVVM相比于MVP的"),l("strong",[t._v("优势")]),t._v("：在常规的开发模式中，数据变化需要更新UI的时候，需要先获取UI控件的引用，然后再更新UI，获取用户的输入和操作也需要通过UI控件的引用，但在MVVM中，这些都是通过"),l("strong",[t._v("数据驱动")]),t._v("来自动完成的，数据变化后会自动更新UI，UI的改变也能自动反馈到数据层，数据成为主导因素。这样MVVM层在业务逻辑处理中只要关心数据，不需要直接和UI打交道，在业务处理过程中简单方便很多。")])])])])]),t._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",{pre:!0,attrs:{class:"language-text"}},[l("code",[t._v("1. 如何理解生产者消费者模型？\n")])])]),l("ul",[l("li",[t._v("技术点：生产者消费者模型")]),t._v(" "),l("li",[t._v("参考回答：生产者消费者模型通过一个缓存队列，既解决了生产者和消费者之间强耦合的问题，又平衡了生产者和消费者的处理能力。\n"),l("ul",[l("li",[t._v("具体规则：生产者只在缓存区未满时进行生产，缓存区满时生产者进程被阻塞；消费者只在缓存区非空时进行消费，缓存区为空时消费者进程被阻塞；当消费者发现缓存区为空时会通知生产者生产；当生产者发现缓存区满时会通知消费者消费。")]),t._v(" "),l("li",[t._v("实现关键：synchronized保证对象只能被一个线程占用；wait()让当前线程进入等待状态，并释放它所持有的锁；notify()&notifyAll()唤醒一个（所有）正处于等待状态的线程")])])])]),t._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",{pre:!0,attrs:{class:"language-text"}},[l("code",[t._v("1. 是否能从Android中举几个例子说说用到了什么设计模式？\n")])])]),l("ul",[l("li",[t._v("技术点：设计模式")]),t._v(" "),l("li",[t._v("参考回答：\n"),l("ul",[l("li",[t._v("View事件分发：责任链模式")]),t._v(" "),l("li",[t._v("BitmapFactory加载图片：工厂模式")]),t._v(" "),l("li",[t._v("Adapter：适配器模式")]),t._v(" "),l("li",[t._v("Builder：建造者模式")]),t._v(" "),l("li",[t._v("Adpter.notifyDataSetChanged()：观察者模式")]),t._v(" "),l("li",[t._v("Binder机制：代理模式")])])])])])}),[],!1,null,null,null);v.default=_.exports}}]);