<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Java面试题1 | InterviewNotes</title>
    <meta name="generator" content="VuePress 1.5.4">
    
    <meta name="description" content="面试笔记">
    <link rel="preload" href="/assets/css/0.styles.7950d16d.css" as="style"><link rel="preload" href="/assets/js/app.60168104.js" as="script"><link rel="preload" href="/assets/js/2.9ef5e12b.js" as="script"><link rel="preload" href="/assets/js/9.dcabcf46.js" as="script"><link rel="prefetch" href="/assets/js/10.cbb282fc.js"><link rel="prefetch" href="/assets/js/11.cdc27a66.js"><link rel="prefetch" href="/assets/js/12.ab8e82c7.js"><link rel="prefetch" href="/assets/js/13.53b1283e.js"><link rel="prefetch" href="/assets/js/14.8c3425fa.js"><link rel="prefetch" href="/assets/js/15.2c1b20e2.js"><link rel="prefetch" href="/assets/js/16.d2bc9b08.js"><link rel="prefetch" href="/assets/js/17.af04b44e.js"><link rel="prefetch" href="/assets/js/18.36d8b51f.js"><link rel="prefetch" href="/assets/js/19.839c51be.js"><link rel="prefetch" href="/assets/js/20.8703ba87.js"><link rel="prefetch" href="/assets/js/21.ec8a48db.js"><link rel="prefetch" href="/assets/js/22.02fa06cd.js"><link rel="prefetch" href="/assets/js/23.8003129d.js"><link rel="prefetch" href="/assets/js/24.49627a6e.js"><link rel="prefetch" href="/assets/js/25.4bc883a8.js"><link rel="prefetch" href="/assets/js/26.fe7b47f6.js"><link rel="prefetch" href="/assets/js/27.1da201b3.js"><link rel="prefetch" href="/assets/js/28.efdeafac.js"><link rel="prefetch" href="/assets/js/29.790c40a3.js"><link rel="prefetch" href="/assets/js/3.d8a31682.js"><link rel="prefetch" href="/assets/js/30.26da2d35.js"><link rel="prefetch" href="/assets/js/31.8569e720.js"><link rel="prefetch" href="/assets/js/32.394a43c4.js"><link rel="prefetch" href="/assets/js/33.059e39bc.js"><link rel="prefetch" href="/assets/js/34.52c2a972.js"><link rel="prefetch" href="/assets/js/35.3219d2fd.js"><link rel="prefetch" href="/assets/js/36.73f2576d.js"><link rel="prefetch" href="/assets/js/37.78b40203.js"><link rel="prefetch" href="/assets/js/38.5b08bd75.js"><link rel="prefetch" href="/assets/js/39.710d1f05.js"><link rel="prefetch" href="/assets/js/4.5ed19beb.js"><link rel="prefetch" href="/assets/js/40.8638dba5.js"><link rel="prefetch" href="/assets/js/41.532c5b33.js"><link rel="prefetch" href="/assets/js/42.b7b9d2c2.js"><link rel="prefetch" href="/assets/js/43.4ead7e96.js"><link rel="prefetch" href="/assets/js/44.b9192d5d.js"><link rel="prefetch" href="/assets/js/45.fc295a45.js"><link rel="prefetch" href="/assets/js/5.feba2b90.js"><link rel="prefetch" href="/assets/js/6.fa972741.js"><link rel="prefetch" href="/assets/js/7.29e8ee4b.js"><link rel="prefetch" href="/assets/js/8.2f455837.js">
    <link rel="stylesheet" href="/assets/css/0.styles.7950d16d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">InterviewNotes</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/hadoop/" class="nav-link">
  hadoop
</a></div><div class="nav-item"><a href="/Java/" class="nav-link router-link-active">
  Java
</a></div><div class="nav-item"><a href="/数据库/" class="nav-link">
  数据库
</a></div><div class="nav-item"><a href="/操作系统/" class="nav-link">
  操作系统
</a></div><div class="nav-item"><a href="/Android.html" class="nav-link">
  Android
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language Menu" class="dropdown-title"><span class="title">Languages</span> <span class="arrow down"></span></button> <button type="button" aria-label="Language Menu" class="mobile-dropdown-title"><span class="title">Languages</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/language/chinese/" class="nav-link">
  Chinese
</a></li><li class="dropdown-item"><!----> <a href="/language/japanese/" class="nav-link">
  Japanese
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/hadoop/" class="nav-link">
  hadoop
</a></div><div class="nav-item"><a href="/Java/" class="nav-link router-link-active">
  Java
</a></div><div class="nav-item"><a href="/数据库/" class="nav-link">
  数据库
</a></div><div class="nav-item"><a href="/操作系统/" class="nav-link">
  操作系统
</a></div><div class="nav-item"><a href="/Android.html" class="nav-link">
  Android
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language Menu" class="dropdown-title"><span class="title">Languages</span> <span class="arrow down"></span></button> <button type="button" aria-label="Language Menu" class="mobile-dropdown-title"><span class="title">Languages</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/language/chinese/" class="nav-link">
  Chinese
</a></li><li class="dropdown-item"><!----> <a href="/language/japanese/" class="nav-link">
  Japanese
</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/Java/" aria-current="page" class="sidebar-link">Java</a></li><li><a href="/Java/设计模式.html" class="sidebar-link">设计模式</a></li><li><a href="/Java/Java面试题1.html" class="active sidebar-link">Java面试题1</a></li><li><a href="/Java/Java面试题2.html" class="sidebar-link">Java面试题2</a></li><li><a href="/Java/Java面试题3.html" class="sidebar-link">Java面试题3</a></li><li><a href="/Java/JVM.html" class="sidebar-link">JVM</a></li><li><a href="/Java/NIO.html" class="sidebar-link">NIO</a></li><li><a href="/Java/Spring.html" class="sidebar-link">Spring</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="java面试题1"><a href="#java面试题1" class="header-anchor">#</a> Java面试题1</h1> <p>1.面向对象编程的四大特性及其含义？</p> <ul><li>技术点：面向对象编程特点</li> <li>思路：分条简述每个特性的含义</li> <li>参考回答：
<ul><li>抽象：对现实世界的事物进行概括，抽象为在计算机虚拟世界中有意义的实体</li> <li>封装：将某事物的属性和行为包装到对象中，构成一个不可分割的独立实体，数据被保护在抽象数据类型的内部，并且尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系</li> <li>继承：子类继承父类，不仅可以有父类原有的方法和属性，也可以增加自己的或者重写父类的方法及属性</li> <li>多态：允许不同类的对象对同一消息做出各自的响应</li></ul></li></ul> <ol><li>String、StringBuffer和StringBuilder的区别？</li></ol> <ul><li>技术点：String</li> <li>参考回答：
<ul><li>String是字符串常量，而StringBuffer、StringBuilder都是字符串变量，即String对象一创建后不可更改，而后两者的对象是可更改的：</li> <li>StringBuffer是线程安全的，而StringBuilder是非线程安全的，这是由于StringBuffer对方法加了同步锁或者对调用的方法加了同步锁</li> <li>String更适用于少量的字符串操作的情况，StringBuilder适用于单线程下在字符缓冲区进行大量操作的情况，StringBuffer适用于多线程下在字符缓冲区进行大量操作的情况</li></ul></li></ul> <ol><li>String a=&quot;&quot;和String a=new String(&quot;&quot;)的的关系和异同？</li></ol> <ul><li>技术点：String</li> <li>参考回答：
<ul><li>通过String a=&quot;&quot;直接赋值的方式得到的是一个字符串常量，存在于常量池；注意，相同内容的字符串在常量池中只有一个，即如果池已包含内容相等的字符串会返回池中的字符串，反之会将该字符串放入池中</li> <li>通过new String(&quot;&quot;)创建的字符串不是常量是实例对象，会在堆内存开辟空间并存放数据，且每个实例对象都有自己的地址空间</li></ul></li> <li>引申：对于用String a=&quot;&quot;和String a=new String(&quot;&quot;)两种方式定义的字符串，判断使用equals()、&quot;==&quot;比较结果是什么</li></ul> <ol><li>Object的equal()和==的区别？</li></ol> <ul><li>技术点：equal()、==</li> <li>参考回答：
<ul><li>equals()：是Object的公有方法，具体含义取决于如何重写，比如String的equals()比较的是两个字符串的内容是否相同</li> <li>&quot;==&quot; ：对于基本数据类型来说，比较的是两个变量值是够是否相等，对于引用类型来说，比较的是两个对象的内存地址是否相同</li></ul></li> <li>引申：对于用String a=&quot;&quot;和String a=new String(&quot;&quot;)两种方式定义的字符串，判断使用equals()、&quot;==&quot;比较结果是什么</li></ul> <ol><li>装箱、拆箱什么含义？</li></ol> <ul><li>技术点：装箱、拆箱</li> <li>参考回答：装箱就是自动将基本数据类型转换为包装器类型，拆箱就是自动将包装器类型转换为基本数据类型</li></ul> <ol><li>int和Integer的区别？</li></ol> <ul><li>技术点：基本数据类型、引用类型</li> <li>参考回答：
<ul><li>Integer是int的包装类，int则是java的一种基本数据类型</li> <li>Integer变量必须实例化后才能使用，而int变量不需要</li> <li>Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值</li> <li>Integer的默认值是null，int的默认值是0</li></ul></li></ul> <ol><li>遇见过哪些运行时异常？异常处理机制知道哪些？</li></ol> <ul><li><p>技术点：Java异常机制</p></li> <li><p>思路：对Throwable异常进行分类说明每种异常的特点和常见问题，简述几种常见异常处理机制，详见<a href="https://www.jianshu.com/p/3718766df5ba" target="_blank" rel="noopener noreferrer">Java基础之异常机制<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></li> <li><p>参考回答：</p></li> <li><p>（1） Throwable继承层次结构，可见分成两大类Error和Exception：</p> <ul><li><p>Error（错误）:指程序<strong>无法</strong>恢复的异常情况，表示运行应用程序中较严重的问题；发生于虚拟机自身、或者在虚拟机试图执行应用时，如Virtual MachineError（Java虚拟机运行错误）、NoClassDefFoundError（类定义错误）；属于<strong>不可查</strong>异常，即不强制程序员必须处理，即使不处理也不会出现语法错误。</p></li> <li><p>Exception（异常）:指程序</p> <p>有可能</p> <p>恢复的异常情况，表示程序本身可以处理的异常。又分两大类：</p> <ul><li><p>RuntimeException（运行时异常）：由程序<strong>自身</strong>的问题导致产生的异常；如NullPointerException（空指针异常）、IndexOutOfBoundsException（下标越界异常）；属于<strong>不可查</strong>异常。</p></li> <li><p>非运行时异常：由程序</p> <p>外部</p> <p>的问题引起的异常；除了RuntimeException以外的异常，如FileNotFoundException（文件不存在异常）；属于</p> <p>可查</p> <p>异常，即强制程序员必须进行处理，如果不进行处理则会出现语法错误。</p> <p>![img](file:///C:/Users/hudal/Documents/My Knowledge/temp/904fe720-b024-4bd5-b95a-3adb329760d8/128/index_files/0.7123040762828401.png)</p></li></ul></li></ul></li> <li><p>（2）常见的异常处理机制有：</p> <ul><li>捕捉异常：由系统自动抛出异常，即try捕获异常-catch处理异常-finally 最终处理</li> <li>抛出异常：在方法中将异常对象<strong>显性</strong>地抛出，之后异常会沿着调用层次向上抛出，交由调用它的方法来处理。配合throws声明抛出的异常和throw抛出异常</li> <li>自定义异常：继承Execption类或其子类</li></ul></li></ul> <ol><li>什么是反射，有什么作用和应用？</li></ol> <ul><li>技术点：反射</li> <li>思路：简述反射的定义、功能和应用，详见<a href="https://www.jianshu.com/p/fcdfb8234b66" target="_blank" rel="noopener noreferrer">Java基础之泛型&amp;反射<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li>参考回答：
<ul><li><strong>含义</strong>：在运行状态中，对于任意一个类都能知道它的所有属性和方法，对于任何一个对象都能够调用它的任何一个方法和属性。</li> <li><strong>功能</strong>：动态性，体现在：在运行时判断任意一个类所具有的属性和方法； 在运行时判断任意一个对象所属的类；在运行时构造任意一个类的对象；在运行时调用任意一个对象的方法；生成动态代理</li> <li>应用：反射&amp;泛型</li></ul></li> <li>引申：是否在项目中使用过反射机制，有什么优缺点</li></ul> <ol><li>什么是内部类？有什么作用？静态内部类和非静态内部类的区别？</li></ol> <ul><li>技术点：内部类</li> <li>思路：</li> <li>参考回答：内部类就是定义在另外一个类里面的类。它隐藏在外部类中，封装性更强，不允许除外部类外的其他类访问它；但它可直接访问外部类的成员。静态内部类和非静态内部类的区别有：
<ul><li>静态内部类是指被声明为static的内部类，可不依赖外部类实例化；而非静态内部类需要通过生成外部类来间接生成。</li> <li>静态内部类只能访问外部类的静态成员变量和静态方法，而非静态内部类由于持有对外部类的引用，可以访问外部类的所用成员</li></ul></li> <li>引申：谈谈匿名内部类</li></ul> <ol><li>final、finally、finalize()分别表示什么含义</li></ol> <ul><li>技术点：final、finally、finalize()</li> <li>参考回答：
<ul><li>final关键字表示不可更改，具体体现在：
<ul><li>final修饰的变量必须要初始化，且赋初值后不能再重新赋值</li> <li>final修饰的方法不能被子类重写</li> <li>final修饰的类不能被继承</li></ul></li> <li>finally：和try、catch成套使用进行异常处理，无论是否捕获或处理异常，finally块里的语句都会被执行，在以下4种特殊情况下，finally块才不会被执行：
<ul><li>在finally语句块中发生了异常</li> <li>在前面的代码中用了<code>System.exit()</code>退出程序</li> <li>程序所在的线程死亡</li> <li>关闭CPU</li></ul></li> <li>finalize()：是Object中的方法，当垃圾回收器将回收对象从内存中清除出去之前会调用finalize()，但此时并不代表该回收对象一定会“死亡”，还有机会“逃脱”</li></ul></li></ul> <ol><li>重写和重载的区别？</li></ol> <ul><li>技术点：重写、重载</li> <li>参考回答：重写表示子类重写父类的方法；重载表示有多个同名函数同时存在，区别在于有不同的参数个数或类型</li> <li>引申：谈谈动态分派和静态分派</li></ul> <ol><li>抽象类和接口的异同？</li></ol> <ul><li>技术点：抽象类、接口</li> <li>参考回答：
<ul><li>使用上的区别：一个类只能继承一个抽象类却可以实现多个接口</li> <li>设计上的区别：接口是对行为的抽象，无需有子类的前提，是自上而下的设计理念；抽象类是对类的抽象，建立于相似子类之上，是自下而上的设计理念</li></ul></li></ul> <ol><li>为什么匿名内部类中使用局部变量要用final修饰？</li></ol> <ul><li>技术点：匿名内部类</li> <li>参考回答：一方面，由于方法中的局部变量的生命周期很短，一旦方法结束变量就要被销毁，为了保证在内部类中能找到外部局部变量，通过final关键字可得到一个外部变量的引用；另一方面，通过final关键字也不会在内部类去做修改该变量的值，保护了数据的一致性。</li></ul> <ol><li>Object有哪些公有方法？</li></ol> <ul><li><p>技术点：Object</p></li> <li><p>思路：列举常见的几个公有方法</p></li> <li><p>参考回答：</p> <ul><li>equals()： 和==作用相似</li> <li>hashCode()：用于哈希查找，重写了equals()一般都要重写该方法</li> <li>getClass()： 获取Class对象</li> <li>wait()：让当前线程进入等待状态，并释放它所持有的锁</li> <li>notify()&amp;notifyAll()： 唤醒一个（所有）正处于等待状态的线程</li> <li>toString()：转换成字符串</li></ul></li> <li><p>引申：equals()和==的不同、在synchronized 同步代码块里wait()和notify()&amp;notifyAll()如何配合、hashCode()和equals()的关系、获取Class对象还有什么方法</p></li> <li><p><a href="https://www.jianshu.com/p/7b9abda70c8f" target="_blank" rel="noopener noreferrer">集合<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></li></ul> <ol><li>Java集合框架中有哪些类？都有什么特点</li></ol> <ul><li>技术点：集合框架</li> <li>思路：分条解释每种类的特点</li> <li>参考回答：可将Java集合框架大致可分为Set、List、Queue 和Map四种体系
<ul><li>Set：代表<strong>无序、不可重复</strong>的集合，常见的类如HashSet、TreeSet</li> <li>List：代表<strong>有序、可重复</strong>的集合，常见的类如动态数组ArrayList、双向链表LinkedList、可变数组Vector</li> <li>Map：代表具有<strong>映射关系</strong>的集合，常见的类如HashMap、LinkedHashMap、TreeMap</li> <li>Queue：代表一种<strong>队列</strong>集合</li></ul></li></ul> <ol><li>集合、数组、泛型的关系，并比较</li></ol> <ul><li>技术点：集合、数组、泛型</li> <li>参考回答：</li> <li>（1）集合和数组的区别：
<ul><li>数组元素可以是基本类型，也可以是对象；数组长度限定；数组只能存储一种类型的数据元素</li> <li>集合元素只能是对象；集合长度可变；集合可存储不同种的数据元素</li></ul></li> <li>（2）泛型相比与集合的好处在于它<strong>安全简单</strong>。具体体现在提供编译时的强类型检查，而不用等到运行；可避免类类型强制转换</li></ul> <ol><li>ArrayList和LinkList的区别？</li></ol> <ul><li>技术点：List对比</li> <li>参考回答：
<ul><li><strong>ArrayList</strong>的底层结构是<strong>数组</strong>，可用索引实现快速查找；是动态数组，相比于数组容量可实现动态增长</li> <li><strong>LinkedList</strong>底层结构是<strong>链表</strong>，增删速度快；是一个<strong>双向循环</strong>链表，也可以被当作堆栈、队列或双端队列</li></ul></li></ul> <ol><li>ArrayList和Vector的区别？</li></ol> <ul><li>技术点：List对比</li> <li>参考回答：
<ul><li><strong>ArrayList</strong>非线程安全，建议在单线程中才使用ArrayList，而在多线程中可以选择Vector或者CopyOnWriteArrayList；默认初始容量为10，每次扩容为原来的1.5倍</li> <li><strong>Vector</strong>使用了synchronized关键字，是<strong>线程安全</strong>的，比ArrayList开销更大，访问更慢；默认初始容量为10，默认每次扩容为原来的2倍，可通过<strong>capacityIncrement</strong>属性设置</li></ul></li></ul> <ol><li>HashSet和TreeSet的区别？</li></ol> <ul><li>技术点：Set对比</li> <li>参考回答：
<ul><li><strong>HashSet</strong>不能保证元素的排列顺序；使用<strong>Hash算法</strong>来存储集合中的元素，有良好的存取和查找性能；通过<code>equal()</code>判断两个元素是否相等，并两个元素的<code>hashCode()</code>返回值也相等</li> <li><strong>TreeSet</strong>是SortedSet接口的实现类，根据元素<strong>实际值的大小</strong>进行排序；采用<strong>红黑树</strong>的数据结构来存储集合元素；支持两种排序方法：<strong>自然排序</strong>（默认情况）和<strong>定制排序</strong>。前者通过实现<strong>Comparable接口</strong>中的<code>compareTo()</code>比较两个元素之间大小关系，然后按升序排列；后者通过实现<strong>Comparator接口</strong>中的<code>compare()</code>比较两个元素之间大小关系，实现定制排列</li></ul></li></ul> <ol><li>HashMap和Hashtable的区别？</li></ol> <ul><li>技术点：Map对比</li> <li>参考回答：
<ul><li><strong>HashMap</strong>基于AbstractMap类，实现了Map、<strong>Cloneable</strong>（能被克隆）、<strong>Serializable</strong>（支持序列化）接口； <strong>非线程安全</strong>；允许存在一个为null的key和任意个为null的value；采用<strong>链表散列</strong>的数据结构，即数组和链表的结合；初始容量为16，填充因子默认为0.75，扩容时是当前容量翻倍，即2capacity</li> <li><strong>Hashtable</strong>基于Map接口和Dictionary类；<strong>线程安全</strong>，开销比HashMap大，如果多线程访问一个Map对象，使用Hashtable更好；不允许使用null作为key和value；底层基于哈希表结构；初始容量为11，填充因子默认为0.75，扩容时是容量翻倍+1，即2capacity+1</li></ul></li></ul> <ol><li>HashMap在put、get元素的过程？体现了什么数据结构？</li></ol> <ul><li>技术点：HashMap</li> <li>参考回答：
<ul><li>向Hashmap中put元素时，首先判断key是否为空，为空则直接调用putForNullKey()，不为空则计算key的hash值得到该元素在数组中的下标值；如果数组在该位置处没有元素，就直接保存；如果有，还要比较是否存在相同的key，存在的话就覆盖原来key的value，否则将该元素保存在链头，先保存的在链尾。</li> <li>从Hashmap中get元素时，计算key的hash值找到在数组中的对应的下标值，返回该key对应的value即可，如果有冲突就遍历该位置链表寻找key相同的元素并返回对应的value</li> <li>由此可看出HashMap采用<strong>链表散列</strong>的数据结构，即数组和链表的结合，在Java8后又结合了红黑树，当链表元素超过8个将链表转换为红黑树</li></ul></li></ul> <ol><li>如何解决Hash冲突？</li></ol> <ul><li>技术点：Hash冲突</li> <li>参考回答：
<ul><li>开放定址法：常见的线性探测方式，在冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表</li> <li>链地址法：将有冲突数组位置生出链表</li> <li>建立公共溢出区：将哈希表分为基本表和溢出表两部分，和基本表发生冲突的元素一律填入溢出表</li> <li>再哈希法：构造多个不同的哈希函数，有冲突使用下一个哈希函数计算hash值</li></ul></li></ul> <ol><li>如何保证HashMap线程安全？什么原理？</li></ol> <ul><li>技术点：ConcurrentHashMap</li> <li>思路：这里回答一种办法，使用ConcurrentHashMap</li> <li>参考回答：ConcurrentHashMap是线程安全的HashMap，它采取锁分段技术，将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。在JDK1.8中对ConcurrentHashmap做了两个改进：
<ul><li>取消segments字段，直接采用<code>transient volatile HashEntry[] table</code>保存数据，将数组元素作为锁，对每一行数据进行加锁，可减少并发冲突的概率</li> <li>数据结构由“数组＋单向链表”变为“数组＋单向链表＋红黑树”，使得查询的时间复杂度可以降低到O(logN)，改进一定的性能。</li></ul></li> <li>引申：LinkHashMap线程安全的底层实现</li></ul> <ol><li>HashMap是有序的吗？如何实现有序？</li></ol> <ul><li>技术点：LinkHashMap</li> <li>思路：这里回答一种办法，使用LinkedHashMap</li> <li>参考回答：HashMap是无序的，而LinkedHashMap是有序的HashMap，默认为插入顺序，还可以是访问顺序，基本原理是其内部通过Entry维护了一个双向链表，负责维护Map的迭代顺序</li> <li>引申：LinkHashMap有序的底层实现</li></ul> <ol><li>HashMap是如何扩容的？如何避免扩容？</li></ol> <ul><li>技术点：HashMap</li> <li>参考回答：
<ul><li>HashMap几个默认值，初始容量为16、填充因子默认为0.75、扩容时容量翻倍。也就是说当HashMap中元素个数超过<code>16*0.75=12</code>时会把数组的大小扩展为<code>2*16=32</code>，然后重新计算每个元素在数组中的位置</li> <li>由于每次扩容还需要重新计算元素Hash值，损耗性能，所以建议在使用HashMap时，最好先估算Map的大小，设置初始值，避免频繁扩容</li></ul></li></ul> <ol><li>hashcode()的作用，与equal()有什么区别？</li></ol> <ul><li><p>技术点：Hash值</p></li> <li><p>参考回答：hashCode()用于计算对象的Hash值，确认对象在散列存储结构中的存储地址。和equal()的区别：</p> <ul><li>equals()比较两个对象的地址值是否相等 ；hashCode()得到的是对象的存储位置，可能不同对象会得到相同值</li> <li>有两个对象，若equals()相等，则hashcode()一定相等；hashcode()不等，则equals()一定不相等；hashcode()相等，equals()可能相等、可能不等</li> <li>使用equals()比较两个对象是否相等效率较低，最快办法是先用hashCode()比较，如果hashCode()不相等，则这两个对象肯定不相等；如果hashCode()相等，此时再用equal()比较，如果equal()也相等，则这两个对象的确相等，反之</li></ul></li> <li><p>并发</p></li></ul> <ol><li>同步和非同步、阻塞和非阻塞的概念</li></ol> <ul><li>技术点：同步、阻塞</li> <li>参考回答：
<ul><li>同步和异步体现的是消息的通知机制：所谓同步，方法A调用方法B后必须等到方法B返回结果才能继续后面的操作；所谓异步，方法A调用方法B后可让方法B在调用结束后通过回调等方式通知方法A</li> <li>阻塞和非阻塞侧重于等待消息时的状态：所谓阻塞，就是在结果返回之前让当前线程挂起；所谓非阻塞，就是在等待时可做其他事情，通过轮询去询问是否已返回结果</li></ul></li></ul> <ol><li>Thread的join()有什么作用？</li></ol> <ul><li>技术点：线程相关方法</li> <li>参考回答：Thread的join()的含义是等待该线程终止，即将挂起调用线程的执行，直到被调用的对象完成它的执行。比如存在两个线程t1和t2，下述代码表示先启动t1，直到t1的任务结束，才轮到t2启动。</li></ul> <p>t1.start();
t1.join();
t2.start();</p> <ol><li>线程的有哪些状态？</li></ol> <ul><li><p>技术点：线程状态</p></li> <li><p>思路：可分条解释每种状态的特点以及如何转换。详见<a href="https://www.jianshu.com/p/90a036212cb4" target="_blank" rel="noopener noreferrer">要点提炼| 理解JVM之内存模型&amp;线程<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></li> <li><p>参考回答：在任意一个时间点，一个线程只能有且只有其中的一种状态：</p> <ul><li><p><strong>新建</strong>（New）：线程创建后尚未启动</p></li> <li><p><strong>运行</strong>（Runable）：包括正在执行（Running）和等待着CPU为它分配执行时间（Ready）两种</p></li> <li><p>无限期等待</p> <p>（Waiting）：该线程不会被分配CPU执行时间，要等待被其他线程显式地唤醒。以下方法会让线程陷入无限期等待状态：</p> <ul><li>没有设置Timeout参数的<code>Object.wait()</code></li> <li>没有设置Timeout参数的<code>Thread.join()</code></li> <li><code>LockSupport.park()</code></li></ul></li> <li><p>限期等待</p> <p>（Timed Waiting）：该线程不会被分配CPU执行时间，但在一定时间后会被系统自动唤醒。以下方法会让线程进入限期等待状态：</p> <ul><li><code>Thread.sleep()</code></li> <li>设置了Timeout参数的<code>Object.wai()</code></li> <li>设置了Timeout参数的<code>Thread.join()</code></li> <li><code>LockSupport.parkNanos()</code></li> <li><code>LockSupport.parkUntil()</code></li></ul></li> <li><p><strong>阻塞</strong>（Blocked）：线程被阻塞。和等待状态不同的是，阻塞状态表示在等待获取到一个<strong>排他锁</strong>，在另外一个线程放弃这个锁的时候发生；而等待状态表示在等待一段<strong>时间</strong>或者<strong>唤醒动作</strong>的发生，在程序等待进入同步区域的时候发生。</p></li> <li><p>结束</p> <p>（Terminated）：线程已经结束执行</p> <p>![img](file:///C:/Users/hudal/Documents/My Knowledge/temp/904fe720-b024-4bd5-b95a-3adb329760d8/128/index_files/0.5876930050946625.png)</p></li></ul></li></ul> <ol><li>什么是线程安全？保障线程安全有哪些手段？</li></ol> <ul><li><p>技术点：线程安全</p></li> <li><p>思路：详见<a href="https://www.jianshu.com/p/ca8801044352" target="_blank" rel="noopener noreferrer">要点提炼| 理解JVM之线程安全&amp;锁优化<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></li> <li><p>参考回答：线程安全就是当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。保证线程安全可从多线程三特性出发：</p> <ul><li><p>原子性</p> <p>（Atomicity）：单个或多个操作是要么全部执行，要么都不执行</p> <ul><li>Lock：保证同时只有一个线程能拿到锁，并执行申请锁和释放锁的代码</li> <li>synchronized：对线程加独占锁，被它修饰的类/方法/变量只允许一个线程访问</li></ul></li> <li><p>可见性</p> <p>（Visibility）：当一个线程修改了共享变量的值，其他线程能够立即得知这个修改</p> <ul><li>volatile：保证新值能<strong>立即</strong>同步到主内存，且每次使用前立即从主内存刷新；</li> <li>synchronized：在释放锁之前会将工作内存新值更新到主存中</li></ul></li> <li><p>有序性</p> <p>（Ordering）：程序代码按照指令顺序执行</p> <ul><li>volatile： 本身就包含了禁止指令重排序的语义</li> <li>synchronized：保证一个变量在同一个时刻只允许一条线程对其进行lock操作，使得持有同一个锁的两个同步块只能串行地进入</li></ul></li></ul></li></ul> <ol><li>ReentrantLock和synchronized的区别?</li></ol> <ul><li><p>技术点：线程安全（ReentrantLock、synchronized）</p></li> <li><p>思路：详见<a href="https://www.jianshu.com/p/ca8801044352" target="_blank" rel="noopener noreferrer">要点提炼| 理解JVM之线程安全&amp;锁优化<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></li> <li><p>参考回答： ReentrantLock与synchronized的</p> <p>不同</p> <p>在于ReentrantLock：</p> <ul><li><strong>等待可中断</strong>：当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。</li> <li><strong>公平锁</strong>：多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。而synchronized是非公平的，即在锁被释放时，任何一个等待锁的线程都有机会获得锁。ReentrantLock默认情况下也是非公平的，但可以通过带布尔值的构造函数改用公平锁。</li> <li><strong>锁绑定多个条件</strong>：一个ReentrantLock对象可以通过多次调用newCondition()同时绑定多个Condition对象。而在synchronized中，锁对象wait()和notify()或notifyAl()只能实现一个隐含的条件，若要和多于一个的条件关联不得不额外地添加一个锁。</li></ul></li></ul> <ol><li>synchronized和volatile的区别？</li></ol> <ul><li>技术点：线程安全（synchronized、volatile）</li> <li>参考回答：
<ul><li>synchronized能保证操作的原子性，而volatile不可以，假设线程A和线程B同时读取到变量a值，A修改a后将值更新到主内存，同时B也修改a值会覆盖A的修改操作</li> <li>synchronized可修饰变量、方法和类，而volatile只能修饰变量</li> <li>synchronized可能会造成线程阻塞，而volatile不会造成线程的阻塞</li></ul></li></ul> <ol><li>synchronized同步代码块还有同步方法本质上锁住的是谁？为什么？</li></ol> <ul><li>技术点：线程安全（synchronized）</li> <li>参考回答：本质上锁住的是对象。在java虚拟机中，每个对象和类在逻辑上都和一个监视器相关联，synchronized本质上是对一个对象监视器的获取。当执行同步代码块或同步方法时，执行方法的线程必须先获得该对象的监视器，才能进入同步代码块或同步方法；而没有获取到的线程将会进入阻塞队列，直到成功获取对象监视器的线程执行结束并释放锁后，才会唤醒阻塞队列的线程，使其重新尝试对对象监视器的获取。</li></ul> <ol><li>sleep()和wait()的区别？</li></ol> <ul><li><p>技术点：sleep()、wait()</p></li> <li><p>参考回答：</p> <ul><li>sleep()来自Thread类；wait()来自Object类</li> <li>sleep()用于线程控制自身流程；而wait()用于线程间通信，配合notify()/notifyAll()在同步代码块或同步方法里使用</li> <li>sleep()的线程不会释放对象锁；wait()会释放对象锁进入等待状态，使得其他线程能使用同步代码块或同步方法</li></ul></li> <li><p>Java新动态</p></li></ul> <ol><li>是否了解Java1.x的特性吗？<code></code>1. 谈谈对面向过程编程、面向对象编程还有面向切面编程的理解</li></ol> <ul><li>可能意图：了解候选者对Java和其他语言的关注度和看法、学习主动性、平时学习习惯</li> <li>思路：Oracle技术网（Java）：https://www.oracle.com/technetwork/cn/java/index.html 、开源中国：https://www.oschina.net ，了解最新动态</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/Java/设计模式.html" class="prev">
        设计模式
      </a></span> <span class="next"><a href="/Java/Java面试题2.html">
        Java面试题2
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.60168104.js" defer></script><script src="/assets/js/2.9ef5e12b.js" defer></script><script src="/assets/js/9.dcabcf46.js" defer></script>
  </body>
</html>
