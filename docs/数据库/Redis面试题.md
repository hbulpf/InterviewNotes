# redis 与 memcatched 的区别

1.redis 不仅支持 K/V 类型的数据，同时还提供了 list set hash zset 等丰富的数据结构.memcatched仅支持K/V

2.redis 支持数据的持久化，有 AOF 和 RDB 两种方式，可用于快速恢复。memcatched重启后数据会全部丢失。

3.redis 支持 virtual memory，并不是将所有数据都一直存储在内存中，当物理内存用完时会使用LRU算法将内存中不常用的数据保存到磁盘中。

 

redis 底层数据结构简单字符串

struct sdshdr{

​    int len;//记录数组长度

​    int free;//记录数组中未使用的字节数量

​    char[];//字节数组

}

优点：

1.常数复杂度获取字符串长度

2.杜绝缓冲区溢出

3.惰性空间释放 减少修改字符串长度时所需要的内存分配次数

4.二进制安全

5.遵循以空字符串结尾，兼容部分C字符串函数

字典

typedef struct dictht{

​    dictEntry **table;//哈希表数组

​    unsigned long size ;//哈希表大小

​    unsigned long sizemask ;哈希表大小掩码

​    unsighed long used;//哈希表已有结点数

} dictht

typedef struct dict{

​    dictType *type ;//类型特定函数

​    void *privdata;//私有数据

​    dictht ht[2];//哈希表

​    int rehashidx;// rehash索引值不进行时，值为-1

}

优点：

1.redis 的字典使用哈希表做为底层实现，每个字典带有两个哈希表，一个用于平时使用，另一个仅在 rehash 时使用。

2.冲突解决方案是 链表

3.对哈希表进行扩展或者收缩时，rehash的过程不是一次性的，而是渐进式的。

压缩列表

​    使用场景：在 list 或 hash 数量少的场景下使用 用一个数组来存储各个结点及头结点，尾结点，长度信息，达到节约空间的目的。

   

过期键的删除策略:惰性删除与定期删除相结合。所以判定一个 key 是否存在一定要在 redis 主上判断

惰性删除：当在主结点进行键值查询时判断当前键是否过期，如果过期则返回NIL 同时在AOP追加显示删除命令通知从结点

定期删除：定时任务定期在指定时间类扫描过期键进行删除

 

## redis事务

redis事务提供了一种“将多个命令打包，然后一次性、按顺序地执行”的机制，执行事务期间不会主动中断，事务结束后才会执行其他客户端的命令。

 

redis事务分三个阶段：

1、开始事务

2.命令入队：可能因为参数不对 或 语法错误出错 此时事务即结束并返回失败信息，不会影响数据的一致性。

 

3.执行事务：可能因为方法与类型不符而出错。比如对K/V的 KEY 调用lpush 方法。redis 只会将错误包含在事务的结果中，但不会引起事务的中断及已经执行的命令结果和后面要执行的命令。

 

所以说 redis 事务是不保证原子性的，也不存在回滚机制。这主要是出于其高性能的考虑。因此对于存在逻辑的事务，建议用 lua脚本。非事务批量可用 pipeline